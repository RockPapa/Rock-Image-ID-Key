<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Idaho Drive – Car Size, Speed & Sounds</title>
<style>
  body {
    margin: 0;
    background: #000;
    overflow: hidden;
    font-family: Arial, sans-serif;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #000;
  }
  #ui {
    position: fixed;
    left: 10px;
    bottom: 10px;
    background: rgba(0,0,0,0.7);
    color: #fff;
    padding: 8px 10px;
    border-radius: 8px;
    font-size: 13px;
    z-index: 10;
  }
  #ui label {
    display: inline-block;
    width: 70px;
  }
  #ui .row {
    margin: 2px 0;
  }
  #carSize, #carSpeed {
    width: 170px;
  }
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="ui">
  <div class="row">
    <label for="carSize">Car size</label>
    <input id="carSize" type="range" min="0.05" max="2.0" step="0.05" value="0.35">
  </div>
  <div class="row">
    <label for="carSpeed">Speed</label>
    <input id="carSpeed" type="range" min="0.2" max="2.0" step="0.05" value="1.0">
  </div>
</div>

<script>
// ============================================================
// Controls
//  Arrow keys  = drive car
//  + / =       = zoom in
//  -           = zoom out
// Run via Apache (http://localhost/...) so pixel reading works.
// ============================================================

// Base driving feel (scaled by speedScale)
const BASE_ACCEL   = 0.30;
const BASE_BRAKE   = 0.55;
const BASE_MAX_FWD = 8;
const BASE_MAX_REV = -3;
const TURN_RATE    = 0.045;
const FRICTION     = 0.93;

// Speed scale from slider
let speedScale = 1.0;

// Base car size in map pixels (height = length)
let BASE_CAR_W = 60;
let BASE_CAR_H = 120;

// Size scale from slider
let carScale = 0.35;

// Zoom parameters
let zoom = 1.0;
const MIN_ZOOM = 0.4;
const MAX_ZOOM = 10.0;
const ZOOM_STEP = 0.15;

// Images
const bg = new Image();
bg.src = "images/town.png";

const carImg = new Image();
carImg.src = "images/blue_car.png";

// Sounds
const engineSound = new Audio("images/car_sound.mp3");
engineSound.loop = true;
engineSound.volume = 0.4;   // adjust to taste

const skidSound = new Audio("images/skid.mp3");
skidSound.volume = 0.8;     // adjust to taste

let engineStarted = false;
let lastOnRoadTime = performance.now();
let lastSkidTime = 0;
const SKID_DELAY_MS = 4000;   // must be off-road this long
const SKID_COOLDOWN_MS = 3000;

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let MAP_W = 0, MAP_H = 0;

// Car state (map coordinates)
const car = {
  x: 0,
  y: 0,
  angle: 0,
  speed: 0
};

const keys = {};
window.addEventListener("keydown", (e) => {
  if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","=","+","-"].includes(e.key)) {
    e.preventDefault();
  }
  keys[e.key] = true;

  // Start engine on first key interaction (required by browsers)
  if (!engineStarted && (e.key === "ArrowUp" || e.key === "ArrowDown" ||
                         e.key === "ArrowLeft" || e.key === "ArrowRight")) {
    engineStarted = true;
    engineSound.play().catch(err => {
      console.warn("Engine play blocked:", err);
    });
  }

  if (e.key === "=" || e.key === "+") {
    zoom = Math.min(MAX_ZOOM, zoom + ZOOM_STEP);
  }
  if (e.key === "-") {
    zoom = Math.max(MIN_ZOOM, zoom - ZOOM_STEP);
  }
});
window.addEventListener("keyup", (e) => { keys[e.key] = false; });

// Sliders
document.getElementById("carSize").addEventListener("input", (e) => {
  carScale = parseFloat(e.target.value);
});
document.getElementById("carSpeed").addEventListener("input", (e) => {
  speedScale = parseFloat(e.target.value);
});

// Resize canvas to map aspect
function resize() {
  if (!MAP_W || !MAP_H) return;

  const aspectMap = MAP_W / MAP_H;
  const aspectWin = window.innerWidth / window.innerHeight;

  if (aspectWin > aspectMap) {
    canvas.height = window.innerHeight;
    canvas.width  = canvas.height * aspectMap;
  } else {
    canvas.width  = window.innerWidth;
    canvas.height = canvas.width / aspectMap;
  }
}
window.addEventListener("resize", resize);

// ------------------------------------------------------------
// Hidden canvas for pixel color detection
// ------------------------------------------------------------
const detectCanvas = document.createElement("canvas");
const detectCtx    = detectCanvas.getContext("2d");
let detectionReady = false;

function prepareDetectionCanvas() {
  detectCanvas.width  = MAP_W;
  detectCanvas.height = MAP_H;
  detectCtx.drawImage(bg, 0, 0);
  detectionReady = true;
}

// BLACK road detection
function isRoadPixel(px, py) {
  if (!detectionReady) return true;
  if (px < 0 || py < 0 || px >= MAP_W || py >= MAP_H) return false;

  try {
    const d = detectCtx.getImageData(px|0, py|0, 1, 1).data;
    const r = d[0], g = d[1], b = d[2];
    return (r < 50 && g < 50 && b < 50);
  } catch (e) {
    console.warn("Pixel read error:", e);
    return true;
  }
}

// Check if ANY sample point on car touches black road
function carHasAnyRoadContact() {
  const w = BASE_CAR_W * carScale;
  const h = BASE_CAR_H * carScale;

  const samples = [
    {x:  0,       y:  h * 0.40},
    {x: -w * 0.3, y:  h * 0.30},
    {x:  w * 0.3, y:  h * 0.30},
    {x:  0,       y:  0},
    {x:  0,       y: -h * 0.30},
  ];

  for (const s of samples) {
    const cosA = Math.cos(car.angle);
    const sinA = Math.sin(car.angle);

    const wx = car.x + s.x * cosA - s.y * sinA;
    const wy = car.y + s.x * sinA + s.y * cosA;

    if (isRoadPixel(wx, wy)) {
      return true;
    }
  }
  return false;
}

// ------------------------------------------------------------
// MAIN LOOP
// ------------------------------------------------------------
function start() {
  // Start roughly on the highway; tweak later if you like
  car.x = MAP_W * 0.25;
  car.y = MAP_H * 0.5;
  car.angle = 0;
  car.speed = 0;
  lastOnRoadTime = performance.now();
  requestAnimationFrame(loop);
}

function loop() {
  const now = performance.now();

  // Effective driving constants including speedScale
  const ACCEL   = BASE_ACCEL   * speedScale;
  const BRAKE   = BASE_BRAKE   * speedScale;
  const MAX_FWD = BASE_MAX_FWD * speedScale;
  const MAX_REV = BASE_MAX_REV * speedScale;

  if (keys["ArrowUp"])    car.speed = Math.min(car.speed + ACCEL, MAX_FWD);
  if (keys["ArrowDown"])  car.speed = Math.max(car.speed - BRAKE, MAX_REV);
  if (keys["ArrowLeft"])  car.angle -= TURN_RATE;
  if (keys["ArrowRight"]) car.angle += TURN_RATE;

  car.speed *= FRICTION;

  car.x += Math.cos(car.angle) * car.speed;
  car.y += Math.sin(car.angle) * car.speed;

  car.x = Math.min(Math.max(car.x, 0), MAP_W - 1);
  car.y = Math.min(Math.max(car.y, 0), MAP_H - 1);

  const onRoad = carHasAnyRoadContact();
  const offRoad = !onRoad;

  if (onRoad) {
    lastOnRoadTime = now;
  }

  if (offRoad) {
    car.speed *= 0.85;

    // Check if we've been off-road long enough to skid
    const offDuration = now - lastOnRoadTime;
    const sinceLastSkid = now - lastSkidTime;
    if (offDuration > SKID_DELAY_MS && sinceLastSkid > SKID_COOLDOWN_MS) {
      lastSkidTime = now;
      skidSound.currentTime = 0;
      skidSound.play().catch(err => {
        console.warn("Skid play blocked:", err);
      });
    }
  }

  // Camera centered on car
  const viewW = MAP_W / zoom;
  const viewH = MAP_H / zoom;

  let sx = car.x - viewW / 2;
  let sy = car.y - viewH / 2;

  sx = Math.max(0, Math.min(sx, MAP_W - viewW));
  sy = Math.max(0, Math.min(sy, MAP_H - viewH));

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(bg, sx, sy, viewW, viewH, 0, 0, canvas.width, canvas.height);

  // Draw car with correct aspect ratio and current scale
  const screenScale = canvas.width / viewW;
  const carDrawW = BASE_CAR_W * carScale * screenScale;
  const carDrawH = BASE_CAR_H * carScale * screenScale;

  const carScreenX = (car.x - sx) * screenScale;
  const carScreenY = (car.y - sy) * screenScale;

  ctx.save();
  ctx.translate(carScreenX, carScreenY);
  ctx.rotate(car.angle);
  ctx.drawImage(carImg, -carDrawW/2, -carDrawH/2, carDrawW, carDrawH);
  ctx.restore();

  // HUD
  ctx.font = "bold 32px Arial";
  ctx.textAlign = "center";
  ctx.lineWidth = 5;
  ctx.strokeStyle = "#000";
  ctx.fillStyle = offRoad ? "#F66" : "#6F6";
  const msg = offRoad ? "OFF ROAD" : "ON ROAD";
  ctx.strokeText(msg, canvas.width/2, 40);
  ctx.fillText(msg,   canvas.width/2, 40);

  ctx.font = "18px Arial";
  ctx.fillStyle = "#FFF";
  ctx.fillText("Arrows drive • +/= zoom in • - zoom out • Sliders: size & speed",
               canvas.width/2, canvas.height - 20);

  requestAnimationFrame(loop);
}

// ------------------------------------------------------------
// INIT – wait for both images to know car aspect
// ------------------------------------------------------------
let bgReady = false;
let carReady = false;

bg.onload = () => {
  bgReady = true;
  MAP_W = bg.width;
  MAP_H = bg.height;
  if (carReady) finishInit();
};

carImg.onload = () => {
  carReady = true;
  const ratio = carImg.width / carImg.height; // sprite aspect
  BASE_CAR_H = 120;
  BASE_CAR_W = BASE_CAR_H * ratio;
  if (bgReady) finishInit();
};

function finishInit() {
  resize();
  prepareDetectionCanvas();
  start();
}
</script>

</body>
</html>
